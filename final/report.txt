Colby Morrison
Final Project Lab Report

Smores:
For this problem, I have 4 processes that will be running in parallel: select.rb, chocolate.rb, graham.rb, and marshmallow.rb. To ensure the correct ordering of selecting and eating, I have a standard semaphore, called "select" (["sem", "select"] as a tuple). The init-ts.rb process initially writes it to tuple space before we get going. The select process tries to take this semaphore from tuple space at the beginning of its loop and whichever food process that does the eating writes a new "select" semaphore to tuple space at the end of its loop. When the select process loops around, it will try and take the "select" semaphore, so it will block until the food process writes it back out, signalling that it is done eating. Thus we get the behavior of select, eat, select, eat, etc. 
Inside the select processes' loop, it picks 2 random ingredients ("chocolate", "graham", or "marshmallow") and writes 2 "table" tuples to tuple space, representing placing these ingredients on the table, for example ["table", "chocolate"] and ["table", "graham"]. Since there are infinite supplies of the ingredients, the select process can do this any number of times. The select process then writes an "eat" tuple to tuple space, tagged with the ingredient it did not select. Continuing our example, it will write ["eat", "marshmallow"]. Each food process waits for its corresponding "eat" tuple at the start of its loop. So, in our example, marshmallow.rb will successfully take ["eat", "marshmallow"] and continue on, while chocolate and graham will block on their takes. I'm essentially using the "eat" tuples as "semaphores on steroids", with the extra tag allowing for more robust communication. The marshmallow process will then take the 2 "table" tuples out of tuple space, we know they will be the correct tuples because we signal the correct process. Marshmallow will then make the smore, and eat! It then writes the select semaphore and we start over.
Its cool than when I watch this run, the select.rb process is firing away really fast and the food processes move much slower, I'd guess on average at about 1/3 of the speed, since all the foods are being randomly selected. 

Water Molecules:
I have a hydrogen and oxygen function that each have 2 output channels, one of type boolean and one of type string. The boolean channel is an input channel to the molecule process and the string channel is an input channel to the waterlog process. The hydrogen and oxygen routines infinitely create atoms of their type by repeatedly sending a "true" signal to the molecule process and then send a message that they've done so to the waterlog. The molecule process holds a count of how many hydrogens and how many oxygens it has seen. Using a select statement, it reads from one of the hydrogen or oxygen boolean channels and increments the correct count. Since these channels are infinitely being written to, the molecule process will always be able to read from one of them and will therefore never block. Similarly, since the molecule's select is in an infinite loop, when one of the atom processes writes to its boolean channel, it will get read on one of the molecule's loops, so none of the atom processes will ever block. After reading from one of the channels, the molecule checks if it has at least 2 hydrogens and at least one oxygen, if so it makes a water molecule and decrements the counts. The waterlog simply prints messages as it sees them. 
